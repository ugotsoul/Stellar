<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Game</title>
    <link rel="stylesheet" href="style.css">
    <script src="jquery.min.js"></script>
</head>

<body>

    <canvas id="canvas" height="700" width="1800">
        Oops, your browser does not support Html5 canvas. Dang.
    </canvas>

    <div id="status">
        This is a game about stars and stuff.
    </div>

    <script>
    $(document).ready(function() {
    	run();
        //Change this function name, it don't make no sense
        keyPosition();

    });

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext('2d');

    //test world boundries
    function gameBoard(x, y, h, w) {
        this.x = x || 100;
        this.y = y || 100;
        this.h = h || 500;
        this.w = w || 1500;
    }

    //instanciate board object
    board = gameBoard();

    // ###############################
    //  Constructer Objects
    // ###############################

    //global player object 
    var player = new Player();

    //# of enemies
    e = 2;

    //creates an array of length player + enemy objects
    var gameElements = new Array();

    //get random integer
    function getRandomInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //add game objects
    function getElements() {
        //add player to game element array
        gameElements.push(player);

        //add e# of enemy to game element array
        for (var b = 0; b < (e); b++) {

            // instanciate enemies in random places on the board
            var rx = getRandomInteger(75, 1700);
            var ry = getRandomInteger(75, 600);
            gameElements.push(new Enemy(rx, ry));
        }
    }

    //draw game elements on canvas
    function drawElements() {
        for (var c = 0; c < gameElements.length; c++) {
            //draw element on canvas
            getGameElementsPos();
            gameElements[c].draw();
            gameElements[c].update();
        }
    }

    //clear & redraw board - needs a set interval function to manage frames per second
    function updateBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawElements();
    }

    function run() {
    	//get elements
    	getElements();
    	
    	//frames per second
    	FPS = 50;
    	intervalHandle = setInterval(
    		function() {
    			drawElements();
    			updateBoard();
    		}, 1000/FPS); 

    }

    // #################################
    //  Get player position with Keypad
    // #################################

    function keyPosition() {

        // event listener for keys
        $(window).keydown(function(evt) {

            $('#status').html('WEEEeeeee!');

            //var to store type of event
    		var moveType;

            //log key movements
            for (var e = 0; e < gameElements.length; e++) {

                if (gameElements[e] instanceof Enemy) {

                    //detect collisions
                   	var collision;
		            var nextX = gameElements[e].x;
		            var nextY = gameElements[e].y;

                    switch (true) {
                        case (evt.keyCode == 40): 
                            //enemy moves up, enemy -y
                            nextY -= player.speed;
                            //console.log('nextY '+nextY);
           	                //console.log('you move down');                      
                            moveType = 'down';
                            break;
                        case (evt.keyCode == 38):
                            //enemy moves down, enemy +y
                            nextY += player.speed;
                            //console.log('nextY '+nextY);
                            //console.log('you move up');
                            moveType = 'up';
                            break;
                        case (evt.keyCode == 37):
                        	//enemy moves right, enemy +x
                        	nextX += player.speed;
                        	//console.log('nextX '+nextX);
                        	//console.log('you move left');
                        	moveType = 'left';
                        	break;
                        case (evt.keyCode == 39):
                        	//enemy moves left, enemy -x
                        	nextX -= player.speed;
                        	//console.log('nextX '+nextX);
                        	//console.log('you move right');
                        	moveType = 'right';
                        	break;
                    }

                    //check ray length of next move
                    collision = collsionDetect(nextX, nextY, gameElements[e]);
                    
                    //move the player if no collision
                    if (collision === false) {
                    movePlayer(moveType, gameElements[e]);
                    }
                    else {
                    	attack(collision, gameElements[e]);
                    }
                }
            }
        });
    }


function movePlayer(moveType, element) {

        //check future move to see if player can move there
        switch(true) {
        	case (moveType == 'up'):
            element.y += player.speed;
          	break;

        	case (moveType == 'down'):       	
            element.y -= player.speed;
        	break;

        	case (moveType == 'left'):
        	
            element.x += player.speed;
        	break;

        	case (moveType == 'right'):
            element.x -= player.speed;
        	break;
        }
}

    function getGameElementsPos() {
        //get player cordinates

        for (var f = 0; f < gameElements.length; f++) {

            //get player cordinates
            if (gameElements[f] instanceof Player) {
                //need to get center of box, html5 canvas draws from top left
                playerX = (gameElements[f].x + (gameElements[f].w / 2));
                playerY = (gameElements[f].y + (gameElements[f].h / 2));
                playerH = gameElements[f].h;
                playerW = gameElements[f].w;
            }
            //get enemy cordinates
            else if (gameElements[f] instanceof Enemy) {
                enemyX = gameElements[f].x;
                enemyY = gameElements[f].y;
                enemyR = gameElements[f].r;

                distX = playerX - enemyX;
                distY = playerY - enemyY;

                hypotenuse = Math.floor(Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2)));

            }
        }
    }

    //collision detection with bounding boxes
    function collsionDetect(nextX, nextY, element) {

        //logic: check if player hit enemy using ray-casting

        //get new hypotenuse
        var nextDistX = window.playerX - nextX;
        var nextDistY = window.playerY - nextY;
        nextH = Math.floor(Math.sqrt(Math.pow(nextDistX, 2) + Math.pow(nextDistY, 2)));

        if ( nextH <= (element.r + Math.floor((player.w * Math.sqrt(2)) / 2))) {
            return (true); }
        else {
            return (false);
        	}
    }


function attack(collision, element) {

	if (collision == true){
		$('#status').html("You were hit, OW! You lost some mass.");
		//logic: if element/enemy colided with an enemy.
			//if enemy1.mass > enemy2.mass
			//hurt enemy2
			//add mass to enemy 1
			//if enemy2.mass < enemy1.mass
			//hurt enemy1
			//add mass to enemy 2
			//if enemy1.mass == enemy2.mass
			//randomly hurt one of the objects

	    //if element collided with player
	    //if mass player (wxh) == zero, end game
	    //else, hurt player

	    //hurt player
	    player.w -= element.attack/2;
	    player.h -= element.attack/2;
	    element.r += element.attack/4;
	}

}

    // constructor objects -- game elements 
    function Player(x, y, w, h, fill) {

        //player attributes
        this.x = x || 500;
        this.y = y || 300; //350
        this.w = w || 50;
        this.h = h || 50;
        this.fill = fill || "red";
        this.mass = (this.w + this.h);
        

        //velocity method here
        //get increases in velocity
        //change movement
        this.speed = 1.3;

        this.update = function() {}


        //draw player method -- change name to draw
        this.draw = function() {
            ctx.fillStyle = this.fill;
            ctx.fillRect(this.x, this.y, this.w, this.h);

            //player center coordinates
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + (this.x + (this.w / 2)) + ' Y: ' + (this.y + (this.h / 2)), (this.x + (this.w / 2)), (this.y + (this.h / 2)));

            //player center distance from enemy center
            //change this to a div
            ctx.fillStyle = '#000';
            ctx.font = "bold 20pt Sans-Serif";
            ctx.fillText('You are ' + window.hypotenuse + ' px from the enemy.', 50, 50);

        }
    }

    function Enemy(x, y, r, fill) {

        //enemy attributes
        this.x = x || 650; // x || 1400;
        this.y = y || 380; // y || 200;
        this.r = r || 60;
        this.fill = fill || "blue";
        this.attack = 4;
        this.velocity = 1;

        //make an attribute that is the enemies attack strength
        //make an attribute that is the enmeies health

        //draw enemy method
        this.draw = function() {

        	//enemy size & style
            ctx.fillStyle = this.fill;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();

            //center coordinates of enemy object
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + this.x + ' Y: ' + this.y, this.x - 40, this.y + 20);


            //change these numbers to variables
            //draw line from center of enemy to center of player
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y);
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2)); // hype
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //height
            ctx.lineTo((player.x+player.w/2) + (this.x - (player.x+player.w/2)), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //width
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.closePath();

            //draw collision box for reference
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y - this.r); //top line is (this.x, this.y-this.r) & (this.x, this.y+this.r)
            ctx.lineTo(this.x + this.r, this.y - this.r);
            ctx.lineTo(this.x + this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y - this.r);
            ctx.lineTo(this.x, this.y - this.r);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();


        }


        //update enemy position
        this.update = function() {

        	//move enemy on its own
        	this.x = this.x + this.velocity/window.FPS;
        	this.y = this.y + this.velocity/window.FPS;

        }
    }
    </script>
</body>

</html>