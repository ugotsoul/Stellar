<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Game</title>
    <link rel="stylesheet" href="style.css">
    <script src="jquery.min.js"></script>
</head>

<body>

    <canvas id="canvas" height="700" width="1800">
        Oops, your browser does not support Html5 canvas. Dang.
    </canvas>

    <div id="status">
        This is a game about stars and stuff.
    </div>

    <script>
    $(document).ready(function() {
    	//run game
    	run();

    	//get arrow key type
    	keyPosition();
    	
    });

    //draw the canvas
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext('2d');


    // ###############################
    //  Constructer Objects
    // ###############################

    //global player object 
    var player = new Player();

    //# of enemies
    e = 1;

    //creates an array of length player + enemy objects
    var gameElements = new Array();

    //get random integer
    function getRandomInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //add game objects
    function getElements() {
        //add player to game element array
        gameElements.push(player);

        //add e# of enemy to game element array
        for (var b = 0; b < (e); b++) {

    	   	var rX;
        	var rY;

            // instanciate enemies in random places on the board
            rX = getRandomInteger(75, 1700);
            rY = getRandomInteger(75, 600);
            gameElements.push(new Enemy(rX, rY));
        }
    }

    //##############################
    // Game constructor
    //##############################
    
    //game world boundries - swap out h & w when you decided on a world size
   	var Game = {
        x: 0,
        y: 0,
        h: 700,
        w: 1800,
        //gravity needed? should this be dependent on type of object?
        gravity: .1,
    };

    Game.proto

    //draw game elements on canvas
    function drawElements() {
        for (var c = 0; c < gameElements.length; c++) {
            //draw element on canvas
            getGameElementsPos();
            gameElements[c].draw();
            gameElements[c].update();
        }
    }

    //clear & redraw board - needs a set interval function to manage frames per second
    function updateBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawElements();
    }

    //runs the game (gets elements, draws game elements, updates game elements) @ 50 FPS
    function run() {
    	//get game objects
    	getElements();
    	
    	//frames per second
    	FPS = 50;
    	intervalHandle = setInterval(
    		function() {
    			drawElements();
    			updateBoard();
    		}, 1000/FPS); 

    }

    // #################################
    //  Get player position with Keypad
    // #################################

    // #################################################################################################
    //  Note: you need to update (or nest data structures in) the array when you have more than 1 enemy! 
    // #################################################################################################    

    //track player movements
	var moveType;

    //movement handler for player
	function keyPosition() {

        // event listener for keys
        $(window).keydown(function(evt) {

            $('#status').html('WEEEeeeee!');

            //log key movements in moveArr
            for (var e = 0; e < gameElements.length; e++) {

                if (gameElements[e] instanceof Enemy) {

                	//get player keypress
                    //detect collisions between player and all enemies on the board
		            var nextX = gameElements[e].x;
		            var nextY = gameElements[e].y;

                    switch (true) {
                        case (evt.keyCode == 40): 
                            //enemy moves up, enemy -y
                            nextY -= player.velocity;               
                            moveType = 'down';
                            break;
                        case (evt.keyCode == 38):
                            //enemy moves down, enemy +y
                            nextY += player.velocity;
                            moveType = 'up';
                            break;
                        case (evt.keyCode == 37):
                        	//enemy moves right, enemy +x
                        	nextX += player.velocity;
                        	moveType = 'left';
                        	break;
                        case (evt.keyCode == 39):
                        	//enemy moves left, enemy -x
                        	nextX -= player.velocity;
                        	moveType = 'right';
                        	break;
                    	}

                    console.log(moveType);
				  	console.log('you moved!');
				  	movePlayer(moveType); 
                    }                 
            	}
        	});
    	};


function movePlayer(moveType) {

		console.log('Moving in this direction '+moveType);

        //cap the player at a max velocity
        switch(true) {
        	case (moveType == 'up'):
        	//angles are too ridged - need to gradually moveType the player along an angle      	
        	player.angle = 270;
        	player.velocity += .1;
          	break;

        	case (moveType == 'down'): 
        	player.angle = 90;
        	player.velocity += .1;      	    
        	break;

        	case (moveType == 'left'):
        	player.angle = 180;
        	player.velocity += .1;      	      
        	break;

        	case (moveType == 'right'):
        	player.angle = 360;
        	player.velocity += .1;
        	break;
        }
}

    function getGameElementsPos() {
        //get player cordinates

        for (var f = 0; f < gameElements.length; f++) {

            //get player cordinates
            if (gameElements[f] instanceof Player) {
                //need to get center of box, html5 canvas draws from top left
                playerX = (gameElements[f].x + (gameElements[f].w / 2));
                playerY = (gameElements[f].y + (gameElements[f].h / 2));
                playerH = gameElements[f].h;
                playerW = gameElements[f].w;
            }
            //get enemy cordinates
            else if (gameElements[f] instanceof Enemy) {
                enemyX = gameElements[f].x;
                enemyY = gameElements[f].y;
                enemyR = gameElements[f].r;

                distX = playerX - enemyX;
                distY = playerY - enemyY;

                hypotenuse = Math.floor(Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2)));

            }
        }
    }



    // constructor objects -- game elements 
    function Player(x, y, w, h, fill) {

        //player attributes
        this.x = x || 500;
        this.y = y || 300; //350
        this.w = w || 50;
        this.h = h || 50;
        this.fill = fill || "red";
        this.mass = this.w + this.h;
        
        //physics attributes here
        this.velocity = 1;
        this.friction = .03;
        //this angle is too accurate, how do I realistically decrease its accuracy?
        this.angle = 0; 
        this.radians = 0;
        this.dx = 0;
        this.dy = 0;


        this.update = function() {
       		//calculate angle of movement along a vector
		    this.radians = this.angle * Math.PI/180;
		    this.dx = Math.cos(this.radians) * (this.velocity*this.friction);
		    this.dy = Math.sin(this.radians) * (this.velocity*this.friction);
		    //move player along vector
        	this.x += this.dx;
        	this.y += this.dy;
        }

        //check if enemy hits game boundries
        this.interact = function () {

        	if ( (this.x+this.w) >= Game.w || (this.x) <= Game.x ) {
        		this.angle=180 - this.angle;
        		//decrease velocity on impact
        		this.velocity -= (this.velocity*this.friction);
        		this.update();
        	}

        	else if ( (this.y) <= Game.y || (this.y+this.h) >= Game.h) {
        		this.angle= 360 - this.angle;
        		//decrease velocity on impact
        		this.velocity -= (this.velocity*this.friction);
        		this.update();	
        	}

        	else {
        		this.update();
        	}
        }

        //draw player method
        this.draw = function() {

        	//check game board restricts, adjust angle of vector accordingly
        	this.interact();

            ctx.fillStyle = this.fill;
            ctx.fillRect(this.x, this.y, this.w, this.h);

            //player center coordinates
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + (this.x + (this.w / 2)) + ' Y: ' + (this.y + (this.h / 2)), (this.x + (this.w / 2)), (this.y + (this.h / 2)));

            //player center distance from enemy center
            //change this to a div
            ctx.fillStyle = '#000';
            ctx.font = "bold 12pt Sans-Serif";
            ctx.fillText('Your velocity is '+ this.velocity , 50, 50);
            ctx.fillText('You are ' + window.hypotenuse + ' px from the enemy.', 50, 75);
            ctx.fillText('You mass is ' + player.mass + '.', 50, 100);

        }
    }

    function Enemy(x, y, r, fill) {

        //enemy attributes
        this.x = x || 650; // x || 1400;
        this.y = y || 380; // y || 200;
        this.r = r || 60;
        this.fill = fill || "blue";
        this.attack = 5;

        //enemy physics
        this.velocity = .1;
        this.radians = 0;
        this.dx = 0;
        this.dy = 0;

        //get random angle of movement along the vector
        this.angle = getRandomInteger(0, 360);

        //check if enemy hits game boundries
        this.interact = function () {
        	
        	if ( (this.x+this.r) >= Game.w || (this.x-this.r) <= Game.x ) {
        		this.angle=180 - this.angle;
        		this.update();
        	}

        	else if ( (this.y-this.r ) <= Game.y || (this.y+this.r) >= Game.h) {
        		this.angle= 360 - this.angle;
        		this.update();	
        	}

		    else if ( window.hypotenuse <= (this.r + Math.floor((player.w * Math.sqrt(2)) / 2))) {
                    console.log('I was hit! OW!');
					
					//hurt player
				    //as the players mass decreases, the enemies attack strength increases
				    //to do this accurately, I need the direction of player movement
				    //and the player needs to gradually 'bounce' away from the enemy
				    //similar to the angle of insidence equation
				    player.mass -= this.attack;
				    player.w -= this.attack/2;
				    player.h -= this.attack/2;
				    player.x += this.attack;
				    player.y -= this.attack;
				    //add mass to the enemy
				    this.r += this.attack/player.mass;
				    //slow the player down
				    player.velocity -= .5;

				    //switch the angle of the player away from enemy
				    player.angle = -this.angle;

				    $('#status').html("You were hit, OW! You lost " + enemy.attack + " health points.");
				    this.update();	
				}
			else {
        		this.update();
        	}
        }

        //update enemy position
        this.update = function() {
		   	//calculate angle of movement along a vector
		    this.radians = this.angle * Math.PI/180;
		    this.dx = Math.cos(this.radians) * this.velocity;
		    this.dy = Math.sin(this.radians) * this.velocity;

        }

        //draw enemy method
        this.draw = function() {

        	//check game board restricts, adjust angle of vector accordingly
        	this.interact();

        	//move enemy on its own
        	this.x += this.dx;
        	this.y += this.dy;

        	//enemy size & style
            ctx.fillStyle = this.fill;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();

            //###############################################
            // Below code is to draw coordinates & check math
            //###############################################


            //center coordinates of enemy object
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + this.x + ' Y: ' + this.y, this.x - 40, this.y + 20);


            //change these numbers to variables
            //draw line from center of enemy to center of player
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y);
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2)); // hype
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //height
            ctx.lineTo((player.x+player.w/2) + (this.x - (player.x+player.w/2)), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //width
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.closePath();

            //draw collision box for reference
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y - this.r); //top line is (this.x, this.y-this.r) & (this.x, this.y+this.r)
            ctx.lineTo(this.x + this.r, this.y - this.r);
            ctx.lineTo(this.x + this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y - this.r);
            ctx.lineTo(this.x, this.y - this.r);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();


        }

    }
    </script>
</body>

</html>