<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Game</title>
    <link rel="stylesheet" href="style.css">
    <script src="jquery.min.js"></script>
</head>

<body>

    <canvas id="canvas" height="700" width="1800">
        Oops, your browser does not support Html5 canvas. Dang.
    </canvas>

    <div id="status">
        This is a game about stars and stuff.
    </div>

    <script>
    $(document).ready(function() {
    	run();
        //Change this function name, it don't make no sense
        keyPosition();

    });

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext('2d');

    //test world boundries
   	var gameBoard = {
        x: 0,
        y: 0,
        h: 700,
        w: 1800,
        gravity: .1,
    };


    // ###############################
    //  Constructer Objects
    // ###############################

    //global player object 
    var player = new Player();

    //# of enemies
    e = 1;

    //creates an array of length player + enemy objects
    var gameElements = new Array();

    //get random integer
    function getRandomInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //add game objects
    function getElements() {
        //add player to game element array
        gameElements.push(player);

        //add e# of enemy to game element array
        for (var b = 0; b < (e); b++) {

    	   	var rX;
        	var rY;

            // instanciate enemies in random places on the board
            rX = getRandomInteger(75, 1700);
            rY = getRandomInteger(75, 600);
            gameElements.push(new Enemy(rX, rY));
        }
    }

    //draw game elements on canvas
    function drawElements() {
        for (var c = 0; c < gameElements.length; c++) {
            //draw element on canvas
            getGameElementsPos();
            gameElements[c].draw();
            gameElements[c].update();
        }
    }

    //clear & redraw board - needs a set interval function to manage frames per second
    function updateBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawElements();
    }

    function run() {
    	//get game objects
    	getElements();
    	
    	//frames per second
    	FPS = 50;
    	intervalHandle = setInterval(
    		function() {
    			drawElements();
    			updateBoard();
    		}, 1000/FPS); 

    }

    // #################################
    //  Get player position with Keypad
    // #################################

    function keyPosition() {

        // event listener for keys
        $(window).keydown(function(evt) {

            $('#status').html('WEEEeeeee!');

            //var to store type of event
    		var moveType;

            //log key movements
            for (var e = 0; e < gameElements.length; e++) {

                if (gameElements[e] instanceof Enemy) {

                    //detect collisions
                   	var collision;
		            var nextX = gameElements[e].x;
		            var nextY = gameElements[e].y;

                    switch (true) {
                        case (evt.keyCode == 40): 
                            //enemy moves up, enemy -y
                            nextY -= player.velocity;
                            //console.log('nextY '+nextY);
           	                //console.log('you move down');                      
                            moveType = 'down';
                            break;
                        case (evt.keyCode == 38):
                            //enemy moves down, enemy +y
                            nextY += player.velocity;
                            //console.log('nextY '+nextY);
                            //console.log('you move up');
                            moveType = 'up';
                            break;
                        case (evt.keyCode == 37):
                        	//enemy moves right, enemy +x
                        	nextX += player.velocity;
                        	//console.log('nextX '+nextX);
                        	//console.log('you move left');
                        	moveType = 'left';
                        	break;
                        case (evt.keyCode == 39):
                        	//enemy moves left, enemy -x
                        	nextX -= player.velocity;
                        	//console.log('nextX '+nextX);
                        	//console.log('you move right');
                        	moveType = 'right';
                        	break;
                    }

                    //check ray length of next move
                    collision = collsionDetect(nextX, nextY, gameElements[e]);
                    
                    //move the player if no collision
                    if (collision === false) {
                    movePlayer(moveType, gameElements[e]);
                    }
                    else {
                    	attack(collision, gameElements[e]);
                    }
                }
            }
        });
    }


//only moving the enemy, need to incremently move the player
function movePlayer(moveType, element) {

        //check future move to see if player can move there
        switch(true) {
        	case (moveType == 'up'):

        	//need to change this to physics behavior of player and enemy along vectors
        	player.angle = 270;
        	player.velocity += .1;
            //element.y += player.velocity;
          	break;

        	case (moveType == 'down'): 
        	player.angle = 90;
        	player.velocity += .1;      	
            //element.y -= player.velocity;
        	break;

        	case (moveType == 'left'):
        	player.angle = 180;
        	player.velocity += .1;      	
            //element.x += player.velocity;
        	break;

        	case (moveType == 'right'):
        	player.angle = 360;
        	player.velocity += .1;
            //element.x -= player.velocity;
        	break;
        }
}

    function getGameElementsPos() {
        //get player cordinates

        for (var f = 0; f < gameElements.length; f++) {

            //get player cordinates
            if (gameElements[f] instanceof Player) {
                //need to get center of box, html5 canvas draws from top left
                playerX = (gameElements[f].x + (gameElements[f].w / 2));
                playerY = (gameElements[f].y + (gameElements[f].h / 2));
                playerH = gameElements[f].h;
                playerW = gameElements[f].w;
            }
            //get enemy cordinates
            else if (gameElements[f] instanceof Enemy) {
                enemyX = gameElements[f].x;
                enemyY = gameElements[f].y;
                enemyR = gameElements[f].r;

                distX = playerX - enemyX;
                distY = playerY - enemyY;

                hypotenuse = Math.floor(Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2)));

            }
        }
    }

    //collision detection with bounding boxes
    function collsionDetect(nextX, nextY, element) {

        //logic: check if player hit enemy using ray-casting

        //get new hypotenuse
        var nextDistX = window.playerX - nextX;
        var nextDistY = window.playerY - nextY;
        nextH = Math.floor(Math.sqrt(Math.pow(nextDistX, 2) + Math.pow(nextDistY, 2)));

        if ( nextH <= (element.r + Math.floor((player.w * Math.sqrt(2)) / 2))) {
            return (true); }
        else {
            return (false);
        	}

    }


function attack(collision, element) {

	if (collision == true){
		$('#status').html("You were hit, OW! You lost some mass.");
		//logic: if element/enemy colided with an enemy.
			//if enemy1.mass > enemy2.mass
			//hurt enemy2
			//add mass to enemy 1
			//if enemy2.mass < enemy1.mass
			//hurt enemy1
			//add mass to enemy 2
			//if enemy1.mass == enemy2.mass
			//randomly hurt one of the objects

	    //if element collided with player
	    //if mass player (wxh) == zero, stop game run, begin end game state
	    //else, hurt player

	    //hurt player
	    //as the players mass decreases, the enemies attack strength increases
	    //to do this accurately, I need the direction of player movement
	    //and the player needs to 'bounce' away from the enemy
	    player.w -= element.attack/player.mass;
	    player.h -= element.attack/player.mass;
	    player.x += element.attack/2;
	    player.y -= element.attack/2;
	    //add mass to the element
	    element.r += element.attack/player.mass;
	}

}

    // constructor objects -- game elements 
    function Player(x, y, w, h, fill) {

        //player attributes
        this.x = x || 500;
        this.y = y || 300; //350
        this.w = w || 50;
        this.h = h || 50;
        this.fill = fill || "red";
        this.mass = (this.w + this.h);
        
        //physics attributes here
        this.velocity = 1;
        this.friction = .08;
        this.angle = 0; 
        this.radians = 0;
        this.dx = 0;
        this.dy = 0;


        this.update = function() {
       		//calculate angle of movement along a vector
		    this.radians = this.angle * Math.PI/180;
		    this.dx = Math.cos(this.radians) * (this.velocity*this.friction);
		    this.dy = Math.sin(this.radians) * (this.velocity*this.friction);
		    //move player along vector
        	this.x += this.dx;
        	this.y += this.dy;
        	//decrease velocity

        }

        //check if enemy hits game boundries
        this.interact = function () {
        	if ( (this.x+this.w) >= gameBoard.w || (this.x) <= gameBoard.x ) {
        		this.angle=180 - this.angle;
        		this.update();
        	}

        	else if ( (this.y) <= gameBoard.y || (this.y+this.h) >= gameBoard.h) {
        		this.angle= 360 - this.angle;
        		this.update();	
        	}

        	else {
        		this.update();
        	}
        }

        //draw player method
        this.draw = function() {

        	//check game board restricts, adjust angle of vector accordingly
        	this.interact();

            ctx.fillStyle = this.fill;
            ctx.fillRect(this.x, this.y, this.w, this.h);

            //player center coordinates
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + (this.x + (this.w / 2)) + ' Y: ' + (this.y + (this.h / 2)), (this.x + (this.w / 2)), (this.y + (this.h / 2)));

            //player center distance from enemy center
            //change this to a div
            ctx.fillStyle = '#000';
            ctx.font = "bold 20pt Sans-Serif";
            ctx.fillText('You are ' + window.hypotenuse + ' px from the enemy.', 50, 50);

        }
    }

    function Enemy(x, y, r, fill) {

        //enemy attributes
        this.x = x || 650; // x || 1400;
        this.y = y || 380; // y || 200;
        this.r = r || 60;
        this.fill = fill || "blue";
        this.attack = 4;

        //enemy physics
        this.velocity = .1;
        this.radians = 0;
        this.dx = 0;
        this.dy = 0;

        //get random angle of movement along the vector
        this.angle = getRandomInteger(0, 360);

        //check if enemy hits game boundries
        this.interact = function () {
        	if ( (this.x+this.r) >= gameBoard.w || (this.x-this.r) <= gameBoard.x ) {
        		this.angle=180 - this.angle;
        		this.update();
        	}

        	else if ( (this.y-this.r ) <= gameBoard.y || (this.y+this.r) >= gameBoard.h) {
        		this.angle= 360 - this.angle;
        		this.update();	
        	}

        	else {
        		this.update();
        	}

        }

        //update enemy position
        this.update = function() {

		   	//calculate angle of movement along a vector
		    this.radians = this.angle * Math.PI/180;
		    this.dx = Math.cos(this.radians) * this.velocity;
		    this.dy = Math.sin(this.radians) * this.velocity;

        }

        //draw enemy method
        this.draw = function() {

        	//check game board restricts, adjust angle of vector accordingly
        	this.interact();

        	//move enemy on its own
        	this.x += this.dx;
        	this.y += this.dy;

        	//enemy size & style
            ctx.fillStyle = this.fill;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();

            //###############################################
            // Below code is to draw coordinates & check math
            //###############################################


            //center coordinates of enemy object
            ctx.fillStyle = '#000';
            ctx.font = "bold 8pt Sans-Serif";
            ctx.fillText('X: ' + this.x + ' Y: ' + this.y, this.x - 40, this.y + 20);


            //change these numbers to variables
            //draw line from center of enemy to center of player
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y);
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2)); // hype
            ctx.lineTo((player.x+player.w/2), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //height
            ctx.lineTo((player.x+player.w/2) + (this.x - (player.x+player.w/2)), (player.y+player.h/2) + (this.y - (player.y+player.h/2))); //width
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.closePath();

            //draw collision box for reference
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.moveTo(this.x, this.y - this.r); //top line is (this.x, this.y-this.r) & (this.x, this.y+this.r)
            ctx.lineTo(this.x + this.r, this.y - this.r);
            ctx.lineTo(this.x + this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y - this.r);
            ctx.lineTo(this.x, this.y - this.r);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();


        }

    }
    </script>
</body>

</html>